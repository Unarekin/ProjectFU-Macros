{
  "name": "Adjust Ability Clock - MATT",
  "type": "script",
  "_id": "tgwV7QniP0lmy6Pq",
  "author": "PPShuIcaH5NYIBgf",
  "img": "modules/erica-pfu-macros/assets/icons/6-Clock.webp",
  "scope": "global",
  "command": "/**\n * Adjust the clock associated with an ability on a given character.\n * This function expects 2 or 3 arguments passed from MATT:\n *  Actor ID, name, UUID, token, or an instance of the Actor object itself\n *  The ID, UUID, name, or instance of the ability with a clock to adjust\n *  Optionally, an option to specify how to adjust the clock in one of the following formats:\n *    #     - Add # to the clock\n *    -#    - Subtract # from the clock\n *    =#    - Set the clock to #\n *    max   - Set the clock to its maximum value\n *    step  - Increase the clock by its step value (usually 1)\n *    -step - Decrease the clock by its step value (usually 1)\n * \n *  If the third argument is omitted, it will default to incrementing the clock.\n * \n * This script supports both the most recent Project FU version (2.4.8 at the time of writing), and 2.3.11,\n * and actually also works for Zero Powers.\n */\n\n(async () => {\n  try {\n    const actor = await coerceActor(args[0]);\n    if (!(actor instanceof Actor)) throw new Error(`Invalid actor: ${args[0]}`);\n\n    const ability = await coerceAbility(actor, args[1]);\n    if (!(ability instanceof Item)) throw new Error(`Unable to locate item: ${args[1]}`);\n\n    const progress = typeof ability.system.progress === \"object\" ? ability.system.progress : typeof ability.system.data.progress === \"object\" ? ability.system.data.progress : undefined;\n    \n    if (typeof progress === \"undefined\") throw new Error(`${ability.name} does not have an associated clock.`);\n  \n\n    const adjust = typeof args[2] === \"string\" ? args[2].trim() : args[2];\n\n    const adjustment = calculateAdjustment(progress, adjust);\n    console.log(\"Final adjustment:\", adjustment, ability);\n\n    if (ability.system.progress) {\n      await actor.updateEmbeddedDocuments(\"Item\", [{\n        _id: ability.id,\n        system: {\n          progress: {\n            current: adjustment\n          }\n        }\n      }])\n    } else if (ability.system.data.progress) {\n      await actor.updateEmbeddedDocuments(\"Item\", [{\n        _id: ability.id,\n        system: {\n          data: {\n            progress: {\n              current: adjustment\n            }\n          }\n        }\n      }])\n    } else {\n      throw new Error(\"Unable to determine how to update ability progress.\");\n    }\n    ui.notifications.info(`Set ${ability.name} clock to ${adjustment}.`, { console: false });\n  } catch (err) {\n    ui.notifications.error(err.message, { console: false });\n    console.error(err);\n  }\n})();\n\n\n/**\n * Attempts to determine an ability from a given UUID, ID, or name\n * @param arg \n */\nasync function coerceAbility(actor, arg) {\n  // Check if it's just already an item\n  if (arg instanceof Item) return arg;\n  if (typeof arg === \"string\") {\n    // Check ID\n    let ability = actor.items.get(arg);\n    if (ability instanceof Item) return ability;\n    // Check name\n    ability = actor.items.getName(arg);\n    if (ability instanceof Item) return ability;\n    // Check UUID\n    ability = await fromUuid(arg);\n    if (ability instanceof Item) return ability;\n  }\n}\n\n/**\n * Attempts to determine an actor for a given UUID, ID, or name\n */\nasync function coerceActor(arg) {\n  // Check UUID\n  let actor = await fromUuid(arg);\n  // Check actor ID\n  if (!actor) actor = game.actors.get(arg);\n  // Check token ID\n  if (!actor) actor = canvas.scene.tokens.get(arg)?.actor;\n  // Check token name\n  if (!actor) actor = canvas.scene.tokens.getName(arg)?.actor;\n  // Check actor name\n  if (!actor) actor = game.actors.getName(arg);\n\n  return actor?.actor ? actor.actor : actor;\n}\n\nfunction calculateAdjustment(progress, adjust) {\n  console.log(\"Calculating adjustment:\", adjust);\n  if (typeof adjust === \"undefined\") {\n    return Math.min(progress.current + 1, progress.max);\n  } else if (typeof adjust == + \"string\" && adjust.trim()[0] === \"+\") {\n    return Math.min(progress.max, parseInt(adjust.trim()));\n  } else if (typeof adjust === \"string\") {\n    const trimmed = adjust.trim();\n    if (trimmed[0] === \"=\") return parseInt(adjust.substring(1));\n    if (trimmed === \"max\") return progress.max;\n    if (trimmed === \"step\") return Math.min(progress.current + progress.step, progress.max);\n    if (trimmed === \"-step\") return Math.max(progress.current - progress.step, 0);\n  } else {\n    const parsed = parseInt(adjust);\n    if (isNaN(parsed)) throw new Error(`Invalid adjustment: ${adjust}`);\n    if (parsed === 0) return 0;\n    return Math.min(Math.max(progress.current + parsed, 0), progress.max);\n  }\n  throw new Error(`Invalid adjustment: ${adjust}`);\n}",
  "folder": null,
  "sort": 0,
  "ownership": {
    "default": 0,
    "PPShuIcaH5NYIBgf": 3
  },
  "flags": {},
  "_stats": {
    "compendiumSource": null,
    "duplicateSource": null,
    "coreVersion": "12.331",
    "systemId": "projectfu",
    "systemVersion": "2.4.8",
    "createdTime": 1736399899650,
    "modifiedTime": 1736399924163,
    "lastModifiedBy": "PPShuIcaH5NYIBgf"
  },
  "_key": "!macros!tgwV7QniP0lmy6Pq"
}
