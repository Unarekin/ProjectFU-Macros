{
  "name": "Sprite Animations Attack",
  "type": "script",
  "_id": "JdH6lTJLhaGToBY6",
  "img": "icons/svg/sword.svg",
  "author": "PPShuIcaH5NYIBgf",
  "scope": "global",
  "sort": 0,
  "ownership": {
    "default": 0,
    "PPShuIcaH5NYIBgf": 3
  },
  "flags": {},
  "_stats": {
    "compendiumSource": null,
    "duplicateSource": null,
    "coreVersion": "12.331",
    "systemId": "projectfu",
    "systemVersion": "2.4.8",
    "createdTime": 1741929403279,
    "modifiedTime": 1741929475827,
    "lastModifiedBy": "PPShuIcaH5NYIBgf"
  },
  "_key": "!macros!JdH6lTJLhaGToBY6",
  "command": "/**\n * Sprite Animations Attack Macro\n * This macro provides a basic way to run a series of animations on an attacking sprite\n * to try and emulate the \"approach and hit\" style seen in JRPGs\n *\n * This macro is expected to be executed via Automated Animations, passing a single argument\n * that is a JSON object in the following format:\n */\n\nconst DEFAULT_CONFIGURATION = {\n  idleAnimation: \"idle\",\n  approachAnimation: \"run\",\n  retreatAnimation: \"jump\",\n  attackAnimation: \"attack\",\n  critAnimation: \"\",\n  fumbleAnimation: \"\",\n  hitDelay: 500,\n  critDelay: 1200,\n  approachTime: 1000,\n  retreatTime: 750,\n  playPerTarget: true,\n  attackSound: \"\",\n  hitSound: \"\",\n  missSound: \"\",\n  critSound: \"\",\n  fumbleSound: \"\",\n  attackSoundDelay: 0,\n  hitSoundDelay: 0,\n  missSoundDelay: 0,\n  critSoundDelay: 0,\n  fumbleSoundDelay: 0,\n  attackSoundVolume: 1,\n  hitSoundVolume: 1,\n  missSoundVolume: 1,\n  critSoundVolume: 1,\n  fumbleSoundVolume: 1,\n  hitFlashColor: \"red\",\n  hitFlashTime: 250,\n};\n\nconst SETTINGS_FLAG = \"spriteAnimationsAttackMacroSettings\";\n\ntry {\n  if (!game.modules.get(\"sequencer\")?.active)\n    throw new Error(\"This macro requires Sequencer be active and enabled.\");\n\n  if (!args[2]) throw new Error(\"No animation configuration provided.\");\n  const [chatMessage, aaHandler] = args;\n  const token = aaHandler.sourceToken;\n\n  if (!token) throw new Error(\"Unable to determine token.\");\n\n  const config = foundry.utils.mergeObject(DEFAULT_CONFIGURATION, args[2]);\n\n  const tokenAnimations = SpriteAnimator.getAnimations(token).map(\n    (anim) => anim.name\n  );\n\n  const tokenSettings = (\n    token.actor ? token.actor : token.document ? token.document : token\n  ).getFlag(\"world\", SETTINGS_FLAG);\n\n  const sourceX = token.x;\n  const sourceY = token.y;\n\n  const flags = chatMessage.flags.projectfu.CheckV2;\n  const { critical, fumble } = flags;\n\n  if (!config.critAnimation) config.critAnimation = config.attackAnimation;\n  if (!config.fumbleAnimation) config.fumbleAnimation = config.attackAnimation;\n  if (!config.retreatAnimation)\n    config.retreatAnimation = config.approachAnimation;\n\n  const attackHitDelay = (critical ? config.critDelay : config.hitDelay) ?? 0;\n\n  const shouldApproach =\n    aaHandler.allTargets.length &&\n    config.approachAnimation &&\n    tokenAnimations.includes(config.approachAnimation) &&\n    game.modules.get(\"sequencer\")?.active;\n\n  async function playAttackAnimation(target, data) {\n    const pos = { x: 0, y: 0 };\n    const hit = data?.result === \"hit\";\n    if ((target && target instanceof Token) || target instanceof Tile) {\n      pos.x = target.x;\n      pos.y =\n        target.y +\n        target.document.height * canvas.scene.dimensions.size -\n        token.document.height * canvas.scene.dimensions.size;\n\n      if (sourceX > target.x)\n        pos.x += target.document.width * canvas.scene.dimensions.size;\n      else if (sourceX < target.x)\n        pos.x -= token.document.width * canvas.scene.dimensions.size;\n    } else {\n      pos.x = target.x;\n      pos.y = target.y;\n    }\n\n    // Approach\n    if (shouldApproach) {\n      await new Sequence()\n        .spriteAnimation(token)\n        .add(config.approachAnimation)\n        .immediate(true)\n        .animation()\n        .on(token)\n        .moveTowards(pos)\n        .duration(config.approachTime)\n        .waitUntilFinished()\n        .play();\n    }\n\n    // Hit/miss animation\n    if ((target && target instanceof Tile) || target instanceof Token) {\n      const settings = (\n        target.actor ? target.actor : target.document ? target.document : target\n      ).getFlag(\"world\", SETTINGS_FLAG);\n      const hitAnimation =\n        hit && settings?.hitAnimation\n          ? settings.hitAnimation\n          : !hit && settings?.missAnimation\n          ? settings.missAnimation\n          : \"\";\n      const hitDelay =\n        hit && settings?.hitDelay\n          ? settings.hitDelay\n          : !hit && settings?.missDelay\n          ? settings.missDelay\n          : 0;\n      if (hitAnimation) {\n        const anims = [hitAnimation];\n        if (settings?.defaultAnimation) anims.push(settings.defaultAnimation);\n        wait(attackHitDelay + hitDelay)\n          .then(() => SpriteAnimator.playAnimations(target, ...anims))\n          .catch(console.error);\n      }\n      if (hit && config.hitFlashColor && config.hitFlashTime) {\n        const seq = new Sequence();\n        const color = new PIXI.Color(config.hitFlashColor);\n\n        seq.wait(attackHitDelay + hitDelay);\n        seq.animation().on(target).tint(color.toHex());\n        seq.wait(config.hitFlashTime);\n        seq.animation().on(target).tint(0xffffff).play();\n      }\n    }\n\n    const attackSound =\n      (critical\n        ? config.critSound\n        : fumble\n        ? config.fumbleSound\n        : hit\n        ? config.hitSound\n        : config.missSound) ?? \"\";\n    const soundDelay =\n      (critical\n        ? config.critSoundDelay\n        : fumble\n        ? config.fumbleSoundDelay\n        : hit\n        ? config.hitSoundDelay\n        : config.missSoundDelay) ?? 0;\n    const soundVolume =\n      (critical\n        ? config.critSoundVolume\n        : fumble\n        ? config.fumbleSoundVolume\n        : hit\n        ? config.hitSoundVolume\n        : config.missSoundVolume) ?? 0;\n\n    if (attackSound) {\n      new Sequence()\n        .wait(soundDelay)\n        .sound()\n        .file(attackSound)\n        .volume(soundVolume)\n        .play();\n    }\n\n    // Attack animation\n    const attackAnimation = critical\n      ? config.critAnimation\n      : fumble\n      ? config.fumbleAnimation\n      : config.attackAnimation;\n\n    if (config.attackSound) {\n      const seq = new Sequence();\n      if (config.attackSoundDelay) seq.wait(config.attackSoundDelay);\n      seq\n        .sound()\n        .file(config.attackSound)\n        .volume(config.attackSoundVolume ?? 1)\n        .play();\n    }\n\n    await new Sequence()\n      .spriteAnimation(token)\n      .add(attackAnimation)\n      .immediate(true)\n      .waitUntilFinished()\n      .play();\n  }\n\n  if (aaHandler.allTargets.length > 1 && !config.playPerTarget) {\n    // Determine average position\n    const pos = aaHandler.allTargets.reduce(\n      (prev, curr, i) => {\n        return {\n          x:\n            prev.x +\n            curr.x +\n            curr.document.width * canvas.scene.dimensions.size,\n          y:\n            prev.y +\n            curr.y +\n            curr.document.height * canvas.scene.dimensions.size,\n        };\n      },\n      { x: 0, y: 0 }\n    );\n    pos.x /= aaHandler.allTargets.length;\n    pos.y /= aaHandler.allTargets.length;\n\n    // Align to mid-point\n    if (sourceX > pos.x)\n      pos.x += token.document.width * canvas.scene.dimensions.size;\n    else if (sourceX < pos.x)\n      pos.x -= token.document.width * canvas.scene.dimensions.size;\n\n    pos.y -= token.document.height * canvas.scene.dimensions.size;\n\n    await playAttackAnimation(pos);\n  } else if (aaHandler.allTargets.length) {\n    // Sort by leading edge\n    const targets = aaHandler.allTargets.sort((a, b) => {\n      const edgeA =\n        sourceX > a.x\n          ? a.x + a.document.width * canvas.scene.dimensions.size\n          : a.x - a.document.width * canvas.scene.dimensions.size;\n      const edgeB =\n        sourceX > b.x\n          ? b.x + b.document.width * canvas.scene.dimensions.size\n          : b.x - b.document.width * canvas.scene.dimensions.size;\n      return edgeB - edgeA;\n    });\n\n    // Iterate\n    for (let i = 0; i < targets.length; i++) {\n      await playAttackAnimation(\n        aaHandler.allTargets[i],\n        flags.additionalData.targets[i]\n      );\n    }\n  } else {\n    await playAttackAnimation({ x: token.x, y: token.y });\n  }\n\n  // Retreat\n  if (shouldApproach) {\n    await new Sequence()\n      .spriteAnimation(token)\n      .add(config.retreatAnimation ?? config.approachAnimation)\n      .immediate(true)\n      .animation()\n      .on(token)\n      .moveTowards({ x: sourceX, y: sourceY })\n      .duration(config.retreatTime ?? config.approachTime)\n      .waitUntilFinished()\n      .play();\n  }\n\n  if (tokenSettings.defaultAnimation)\n    SpriteAnimator.playAnimation(token, tokenSettings.defaultAnimation);\n} catch (err) {\n  ui.notifications.error(err.message, { console: false });\n  console.error(err);\n}\n\nfunction wait(ms) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n"
}