{
  "name": "Sprite Animations Attack",
  "type": "script",
  "_id": "JdH6lTJLhaGToBY6",
  "img": "icons/svg/sword.svg",
  "author": "PPShuIcaH5NYIBgf",
  "scope": "global",
  "sort": 0,
  "ownership": {
    "default": 0,
    "PPShuIcaH5NYIBgf": 3
  },
  "flags": {},
  "_stats": {
    "compendiumSource": null,
    "duplicateSource": null,
    "coreVersion": "12.331",
    "systemId": "projectfu",
    "systemVersion": "2.4.8",
    "createdTime": 1741929403279,
    "modifiedTime": 1741929475827,
    "lastModifiedBy": "PPShuIcaH5NYIBgf"
  },
  "_key": "!macros!JdH6lTJLhaGToBY6",
  "command": "/**\n * Sprite Animations Attack Macro\n * This macro provides a basic way to run a series of animations on an attacking sprite\n * to try and emulate the \"approach and hit\" style seen in JRPGs\n *\n * This macro is expected to be executed via Automated Animations, passing a single argument\n * that is a JSON object in the following format:\n */\n\nconst DEFAULT_CONFIGURATION = {\n  idleAnimation: \"idle\",\n  approachAnimation: \"run\",\n  retreatAnimation: \"jump\",\n  attackAnimation: \"attack\",\n  hitAnimation: \"hit\",\n  missAnimation: \"miss\",\n  targetIdleAnimation: \"idle\",\n  critAnimation: \"crit\",\n  fumbleAnimation: \"\",\n\n  hitDelay: 500,\n  critDelay: 1200,\n  hitFlashColor: \"red\",\n  hitFlashTime: 75,\n  approachTime: 1000,\n  retreatTime: 750,\n\n  targetOffsetX: 0,\n  targetOffsetY: 0,\n};\n\ntry {\n\n  if (!(game.modules.get(\"sprite-animations\")?.active)) throw new Error(\"This macro requires the Sprite Animations module to be installed and active.\");\n\n  if (!args[2]) throw new Error(\"No animation configuration provided.\");\n\n  const [chatMessage, aaHandler] = args;\n\n  const token = canvas.scene.tokens.get(chatMessage.speaker.token);\n  if (!token) throw new Error(\"Unable to determine token.\");\n\n  const tokenAnimations = SpriteAnimator.getAnimations(token).map(\n    (anim) => anim.name\n  );\n\n  const sourceX = token.x;\n  const sourceY = token.y;\n\n  const config = foundry.utils.mergeObject(DEFAULT_CONFIGURATION, args[2]);\n\n  if (!config.critAnimation) config.critAnimation = config.attackAnimation;\n  if (!config.fumbleAnimation) config.fumbleAnimation = config.attackAnimation;\n  if (!config.retreatAnimation)\n    config.retreatAnimation = config.approachAnimation;\n\n  const animator = new SpriteAnimator(token);\n  const flags = chatMessage.flags.projectfu.CheckV2;\n  const { critical, fumble } = flags;\n\n  const attackAnimation = critical\n    ? config.critAnimation\n    : fumble\n    ? config.fumbleAnimation\n    : config.attackAnimation;\n\n  if (!flags.additionalData.targets.length) {\n    if (attackAnimation && tokenAnimations.includes(attackAnimation)) {\n      await animator.playAnimations(attackAnimation, config.idleAnimation);\n    }\n  } else {\n    for (let i = 0; i < flags.additionalData.targets.length; i++) {\n      const targetObj = flags.additionalData.targets[i];\n      const hit = targetObj.result === \"hit\";\n      // const target = (await fromUuid(targetObj?.uuid))?.token;\n      const target = aaHandler.allTargets[i];\n      const targetAnimator = new SpriteAnimator(target);\n      const targetAnimations = SpriteAnimator.getAnimations(target).map(\n        (anim) => anim.name\n      );\n\n      const shouldApproach =\n        target &&\n        config.approachAnimation &&\n        tokenAnimations.includes(config.approachAnimation) &&\n        game.modules.get(\"sequencer\")?.active;\n\n      if (shouldApproach) {\n        animator.playAnimation(config.approachAnimation).catch(console.error);\n        const pos = {\n          x: target.x + target.width,\n          y: target.y + target.height / 2,\n        };\n\n        await new Sequence()\n          .animation()\n          .on(token)\n          .duration(config.approachTime)\n          .moveTowards(pos)\n          .waitUntilFinished()\n          .play();\n      }\n\n      // Handle target hit/miss animation and flash\n      if (hit) {\n        // Play hit animation\n        if (\n          config.hitAnimation &&\n          targetAnimations.includes(config.hitAnimation)\n        ) {\n          wait(critical ? config.critDelay : config.hitDelay)\n            .then(() =>\n              targetAnimator.playAnimations(\n                config.hitAnimation,\n                config.targetIdleAnimation\n              )\n            )\n            .catch(console.error);\n        }\n\n        if (\n          config.hitFlashColor &&\n          config.hitFlashTime &&\n          game.modules.get(\"tokenmagic\")?.active\n        ) {\n          // Do hit flash\n          const filterParams = {\n            filterType: \"adjustment\",\n            filterId: foundry.utils.randomID(),\n            saturation: 1,\n            brightness: 1,\n            contrast: 1,\n            gamma: 1,\n            red: 1,\n            green: 0,\n            blue: 0,\n            alpha: 1,\n          };\n          wait(critical ? config.critDelay : config.hitDelay)\n            .then(() => TokenMagic.addFilters(target, [filterParams]))\n            .then(() => wait(config.hitFlashTime))\n            .then(() => TokenMagic.deleteFilters(target, filterParams.filterId))\n            .catch(console.error);\n        }\n      } else if (\n        !hit &&\n        config.missAnimation &&\n        targetAnimations.includes(config.missAnimation)\n      ) {\n        // Play miss animation\n        wait(critical ? config.critDelay : config.hitDelay)\n          .then(() =>\n            targetAnimator.playAnimations(\n              config.missAnimation,\n              config.targetIdleAnimation\n            )\n          )\n          .catch(console.error);\n      }\n\n      // Perform token attack animation\n      if (attackAnimation && tokenAnimations.includes(attackAnimation)) {\n        await animator.playAnimation(attackAnimation);\n        if (shouldApproach) {\n          // Retreat\n          animator.playAnimation(config.retreatAnimation).catch(console.error);\n          await new Sequence()\n            .animation()\n            .on(token)\n            .moveTowards({ x: sourceX, y: sourceY })\n            .duration(config.retreatTime)\n            .waitUntilFinished()\n            .play();\n        }\n      }\n\n      // Return to idle\n      await animator.playAnimation(config.idleAnimation);\n    }\n  }\n} catch (err) {\n  ui.notifications?.error(err instanceof Error ? err.message : err, {\n    localize: true,\n  });\n}\n\nasync function wait(ms) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}"
}
